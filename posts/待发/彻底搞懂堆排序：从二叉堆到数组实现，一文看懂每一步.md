---
title: 彻底搞懂堆排序：从二叉堆到数组实现，一文看懂每一步
date: 2025-09-05
updated: 2025-09-10
category: programming
tags:
  - "java"
  - "算法"
---



如果你学过归并排序和快速排序，可能会觉得它们“靠逻辑”；但当你第一次看到**堆排序**时，大概率会冒出三个问号：

> - 堆是个啥？是数据结构还是算法？
> - 为什么建堆要从 `n/2 - 1` 开始？
> - `heapify` 到底在干什么？为什么要递归？

别急。今天我们不讲术语堆砌，也不甩公式，就用一张张“演变图” + 一行行代码解析，带你从零理解堆排序的**每一个动作背后的逻辑**。

准备好了吗？我们开始。

## 一、堆的本质：一棵用数组伪装的二叉树

堆（Heap）是一种特殊的**完全二叉树**，分为大顶堆和小顶堆：

- **大顶堆**：父节点 ≥ 子节点 → 根是最大值
- **小顶堆**：父节点 ≤ 子节点 → 根是最小值

而堆排序用的是**大顶堆**，目标很明确：

> **不断把最大值拿出来，放到数组末尾，直到整个数组有序。** 

但关键来了：**我们不用真的建一棵树！**

> 🌲 堆是“用数组表示的二叉树”。 

### 📐 数组如何表示二叉树？索引的秘密

我们有一个数组：

```java
int[] arr = {64, 34, 25, 12, 22, 11, 90};
```

它的索引是：

```
索引： 0   1   2   3   4   5   6
值：  64, 34, 25, 12, 22, 11, 90
```

我们可以把它看成一棵完全二叉树：

```
        64(0)
       /    \
    34(1)   25(2)
   /  \     /  \
12(3) 22(4) 11(5) 90(6)
```

父子节点的索引关系是固定的：

| 节点 | 左孩子 | 右孩子 | 父节点  |
| ---- | ------ | ------ | ------- |
|      | 2*i+1  | 2*i+2  | (i-1)/2 |

👉 这个规则是堆排序的“地基”，一定要记住。

## 二、建堆：从下往上“修房子”

堆排序的第一步是：**把乱序数组变成一个大顶堆**。

怎么做？不是从上往下，而是**从最后一个非叶子节点开始，从下往上逐个“下沉”调整**。

### ❓ 为什么要从 `n/2 - 1` 开始？

因为：**只有非叶子节点才需要调整**，叶子节点没有孩子，没法比大小。

最后一个非叶子节点，就是**最后一个节点的父节点**。

最后一个节点索引是 `n-1`，它的父节点是：

​											parent=(*n*−2)/2

等价于：

​												*n*/2−1

对于 `n = 7`，`7 / 2 - 1 = 2` → 所以我们从索引 `2` 开始。

### 🔨 建堆过程：一步步“下沉”调整

我们从 `i = 2` 开始，往前处理每个非叶子节点。

#### 第一步：处理 `i = 2`（值为 25）

```
当前结构：
        64(0)
       /    \
    34(1)   25(2)
   /  \     /    \
12(3) 22(4) 11(5) 90(6)
```

- 左孩子：`2*2+1=5 → 11`
- 右孩子：`2*2+2=6 → 90`
- 最大值是 `90`，比 `25` 大 → 交换！

交换后：

```
        64(0)
       /    \
    34(1)   90(2)
   /  \     /    \
12(3) 22(4) 11(5) 25(6)
```

数组变为：`[64, 34, 90, 12, 22, 11, 25]`

#### 第二步：处理 `i = 1`（值为 34）

```
        64(0)
       /    \
    34(1)   90(2)
   /  \     /    \
12(3) 22(4) 11(5) 25(6)
```

- 左孩子：`3 → 12`
- 右孩子：`4 → 22`
- 最大是 `34` 自己 → 不动

#### 第三步：处理 `i = 0`（值为 64）

```
        64(0)
       /    \
    34(1)   90(2)
   /  \     /    \
12(3) 22(4) 11(5) 25(6)
```

- 左孩子：`1 → 34`
- 右孩子：`2 → 90`
- 最大是 `90`，比 `64` 大 → 交换！

交换后：

```
        90(0)
       /    \
    34(1)   64(2)
   /  \     /    \
12(3) 22(4) 11(5) 25(6)
```

数组变为：`[90, 34, 64, 12, 22, 11, 25]`

✅ 此时整个数组已是一个大顶堆，最大值 `90` 在根节点。

## 三、排序：不断“选最大”并归位

现在堆建好了，接下来就是排序阶段：

> **每次把堆顶（最大值）和末尾交换，然后缩小堆，再调整堆。** 

我们用一个循环，从 `i = n-1` 到 `i > 0`：

```java
for (int i = n - 1; i > 0; i--) {
    swap(arr, 0, i);       // 最大值放到末尾
    heapify(arr, i, 0);    // 重新调整堆（大小为 i）	
}
```

### 第一次：`i = 6`，交换 `arr[0]` 和 `arr[6]`

```
堆：[90, 34, 64, 12, 22, 11, 25]
交换 90 和 25：
→ [25, 34, 64, 12, 22, 11, 90]
```

现在 `90` 已归位（最后一位），我们对前 6 个元素调用 `heapify(0)`：

- `25` 是根，左右孩子是 `34` 和 `64`，最大是 `64`
- 交换 `25` 和 `64` → `[64, 34, 25, 12, 22, 11, 90]`
- 继续下沉 `25`，但它比孩子小，不再交换

调整后堆为：`[64, 34, 25, 12, 22, 11]`，`90` 已排好。

### 第二次：`i = 5`，交换 `arr[0]` 和 `arr[5]`

```
交换 64 和 11：
→ [11, 34, 25, 12, 22, 64, 90]
```

对前 5 个元素调整：

- `11` 是根，左孩子 `34` 更大 → 交换
- 变成 `[34, 11, 25, 12, 22]`
- `11` 继续下沉？左孩子 `12` 更大 → 再交换
- 变成 `[34, 12, 25, 11, 22]`

最终：`[34, 12, 25, 11, 22, 64, 90]`

### 后续过程（简略）

继续这个过程：

| 步骤 | 堆顶交换 | 调整后数组                      |
| ---- | -------- | ------------------------------- |
| 3    | 34 ↔ 22  | →`[22, 12, 25, 11, 34, 64, 90]` |
| 4    | 25 ↔ 11  | →`[11, 12, 22, 25, 34, 64, 90]` |
| 5    | 12 ↔ 11  | →`[11, 12, 22, 25, 34, 64, 90]` |
| 6    | 11 不动  | 排序完成 ✅                      |

最终数组完全有序。

## 四、`heapify` 函数：堆的“自我修复”机制

这是堆排序的核心函数：

```java
private static void heapify(int[] arr, int heapSize, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, heapSize, largest); // 递归下沉
    }
}
```

### 它在做什么？—— 重点：为什么必须递归？

我们已经知道，`heapify` 的目标是：**让以 `i` 为根的子树重新满足大顶堆的性质**。

但关键在于：**一次交换，往往只是“治标”，真正的“治本”需要一路追踪被换下去的节点**。

让我们看一个具体例子：

假设当前堆结构如下（数组表示）：

```
索引： 0   1   2   3   4   5   6
值：  [10, 50, 30, 40, 25, 20, 15]
```

对应的二叉树是：

```
        10(0)
       /    \
    50(1)   30(2)
   /  \     /    \
40(3) 25(4) 20(5) 15(6)
```

现在我们要对 `i = 0`（值为 10）调用 `heapify`。显然，它太小了，不配当根。

- 左右孩子中最大是 `50`（索引 1），于是交换 `arr[0]` 和 `arr[1]`：

  数组变成：`[50, 10, 30, 40, 25, 20, 15]`

结构变成：

```
        50(0)
       /    \
    10(1)   30(2)
   /  \     /    \
40(3) 25(4) 20(5) 15(6)
```

✅ 根节点现在是最大值了，看起来没问题？

❌ 但注意：**原来在根的 `10`，现在到了位置 1，而它的孩子是 `40` 和 `25`**！

- `10 < 40`，所以它仍然破坏了以 `1` 为根的子树的大顶堆性质。

👉 如果我们不继续处理，这个堆依然是“局部错误”的。

所以必须对 `largest`（也就是 `1`）**递归调用 `heapify`**：

```java
heapify(arr, heapSize, largest); // largest = 1
```

这次在 `i = 1`：

- 比较 `10`、`40`、`25`，最大是 `40`
- 交换 `arr[1]` 和 `arr[3]` → `[50, 40, 30, 10, 25, 20, 15]`

结构变成：

```
        50(0)
       /    \
    40(1)   30(2)
   /  \     /    \
10(3) 25(4) 20(5) 15(6)
```

继续检查 `i = 3`（值为 10）：

- 它是叶子节点，无孩子 → 递归结束。

✅ 至此，整个堆才真正恢复大顶堆性质。

## 五、总结：三句话搞懂堆排序

1. **堆是一个用数组表示的完全二叉树**，父节点索引 `i` 的孩子是 `2i+1` 和 `2i+2`。
2. **建堆要从 `n/2 - 1` 开始**，因为这是最后一个非叶子节点，只有它们需要“下沉”调整。
3. **每次交换堆顶后都要 `heapify`**，因为堆被破坏了，必须恢复大顶堆性质。